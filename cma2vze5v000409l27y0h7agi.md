---
title: "Git & GitHub Advanced"
datePublished: Tue Apr 29 2025 19:14:45 GMT+0000 (Coordinated Universal Time)
cuid: cma2vze5v000409l27y0h7agi
slug: git-and-github-advanced
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1745954051285/b596b71e-8d0e-4020-b2fc-d7e629300c23.png
tags: github, git-and-github-advanced-challenge

---

Git & GitHub Advanced Challenge This challenge covers advanced Git concepts essential for real-world DevOps workflows. By the end of this challenge, you will: ‚Ä¢ Understand how to work with Pull Requests effectively. ‚Ä¢ Learn to undo changes using Reset & Revert. ‚Ä¢ Use Stashing to manage uncommitted work. ‚Ä¢ Apply Cherry-picking for selective commits. ‚Ä¢ Keep a clean commit history using Rebasing. ‚Ä¢ Learn industry-standard Branching Strategies. Topics Covered

1. Pull Requests ‚Äì Collaborating in teams.
    
2. Reset & Revert ‚Äì Undo changes safely.
    
3. Stashing ‚Äì Saving work temporarily.
    
4. Cherry-picking ‚Äì Selecting specific commits.
    
5. Rebasing ‚Äì Maintaining a clean history.
    
6. Branching Strategies ‚Äì Industry best practices. Challenge Tasks Task 1: Working with Pull Requests (PRs) Scenario: You are working on a new feature and need to merge your changes into the main branch using a Pull Request.
    
7. Fork a repository and clone it locally.
    
8. git clone cd
    
9. Create a feature branch and make changes.
    
10. git checkout -b feature-branch
    
11. echo "New Feature" &gt;&gt; feature.txt
    
12. git add . git commit -m "Added a new feature"
    
13. Push the changes and create a Pull Request. git push origin feature-branch
    
14. Open a PR on GitHub, request a review, and merge it once approved.
    

Steps :- ‚Ä¢ Open your GitHub profile. ‚Ä¢ Navigate to the repository and lick ‚ÄúCompare & Pull Request‚Äù

![image](https://github.com/user-attachments/assets/ef2cd693-e5a2-4972-ac27-b603d8be0fff align="left")

‚Ä¢ Select the base branch where you want to merge and select from which branch you want to merge. ‚Ä¢ Then create pull request.

![image](https://github.com/user-attachments/assets/3cead55f-8102-4ee8-85b1-95727e4382a6 align="left")

‚Ä¢ Once click on the Create pull request.

![image](https://github.com/user-attachments/assets/1fc0a5e8-b3ae-4ff2-9e32-dc21d06bac45 align="left")

‚Ä¢ You need to add the Description also you can ask your senior or colleague to review the pull request and the file that you have created. ‚Ä¢ Once you have assigned the reviewers and the description, then you can create pull request.

![image](https://github.com/user-attachments/assets/f7a892bb-f511-453c-b605-07904284cac4 align="left")

‚Ä¢ As you can see in the screenshot there is no reviewers in it but assume you have assigned the reviewer and they have reviewed the request and approved it. ‚Ä¢ Once it is approved you can see the latest comment. ‚Ä¢ If it is mentioned that it is approved then you just need to click on merge pull request. ‚Ä¢ Then it will ask you to confirm the merge before that always put description.

![image](https://github.com/user-attachments/assets/205e931f-bf12-4c75-9964-e99fa31c3a91 align="left")

‚Ä¢ Once you click on confirm merge then pull request will be succeed.

![image](https://github.com/user-attachments/assets/dff7fdd0-0282-4a5a-8f65-82d25eddd467 align="left")

Document in [solution.md](http://solution.md) ‚Ä¢ Steps to create a PR. ‚Ä¢ Best practices for writing PR descriptions. ‚Ä¢ Handling review comments. üõ†Ô∏è Pull Request (PR) Workflow Guide ‚úÖ Steps to Create a Pull Request (PR)

1. Create a Feature Branch
    

git checkout -b feature/your-feature-name 2. Make Changes and Commit git add . git commit -m "Add a meaningful commit message" 3. Push the Feature Branch git push origin feature/your-feature-name 4. Open a Pull Request on GitHub o Navigate to the repository. o Click "Compare & Pull Request". o Choose the base branch (e.g., main or develop) and your feature branch. o Add a title and description, then click "Create Pull Request".

---

‚úçÔ∏è Best Practices for Writing PR Descriptions Clear communication in PRs improves collaboration and code quality. Structure your description like this: üîç What does this PR do? Brief summary of the change. E.g., "Implements login functionality using JWT." üìã Changes made ‚Ä¢ Added authService.ts for token generation. ‚Ä¢ Updated login API to validate credentials. ‚Ä¢ Added unit tests. ‚úÖ Checklist ‚Ä¢ Code is linted ‚Ä¢ Unit tests added ‚Ä¢ No breaking changes üìù Related Issue Closes #123 or Fixes bug described in \[link\]

---

üí¨ Handling Review Comments

1. Stay open to feedback Reviews are about the code, not you.
    
2. Reply to each comment Acknowledge the feedback. Use: o ‚úÖ Fixed o ü§î Need clarification o üö´ Won‚Äôt fix (with reason)
    
3. Make necessary changes Update your branch with changes and push again: git add . git commit -m "Refactor: address review feedback" git push origin feature/your-feature-name
    
4. Resolve comments on GitHub Mark them as "Resolved" once handled.
    

Task 2: Undoing Changes ‚Äì Reset & Revert Scenario: You accidentally committed incorrect changes and need to undo them.

1. Create and modify a file.
    
2. echo "Wrong code" &gt;&gt; wrong.txt
    
3. git add .
    
    ![image](https://github.com/user-attachments/assets/a9c154fd-1ae3-4a18-bdaf-745b77da128f align="left")
    

git commit -m "Committed by mistake"

4. Soft Reset (keeps changes staged). git reset --soft HEAD~1:- it will untrack and stag the file last committed file.
    
5. Mixed Reset (unstages changes but keeps files). git reset --mixed HEAD~1 :- it will untrack the file last committed file.
    
6. Hard Reset (removes all changes). git reset --hard HEAD~1 :- it will delete the file last committed file.
    

As you can see wrong file is deleted and it also not in untrack.

7. Revert a commit safely. git revert HEAD :- it will revert the last head commit. As per last command git reset ‚Äìhard it will delete the committed the file(wrong file) and the log for it. Not when you do revert HEAD then it will revert the last committed file that will feature file which was committed in task 1.
    

Document in [solution.md](http://solution.md) ‚Ä¢ Differences between reset and revert. ‚Ä¢ When to use each method.

üîÅ Differences Between git reset and git revert üß† Conceptual Difference Feature git reset git revert What it does Moves the branch pointer to an earlier commit Creates a new commit that undoes a previous one Affects history Rewrites commit history Preserves history Safe for shared branches ‚ùå No (can cause issues for others) ‚úÖ Yes (safe for collaboration) Undo visibility Changes are not visible to others (unless pushed with --force) Revert is visible as a new commit

---

üß™ When to Use Each Method ‚úÖ Use git reset when: ‚Ä¢ You're working locally, and ‚Ä¢ You want to undo commits or unstage files without keeping the history. ‚Ä¢ Useful during development or practice. Example: bash CopyEdit git reset --soft HEAD~1 # Undo commit but keep changes staged git reset --mixed HEAD~1 # Undo commit and unstage changes git reset --hard HEAD~1 # Undo commit and discard changes (use with caution!) ‚úÖ Use git revert when: ‚Ä¢ You're working on a shared branch (e.g., main, develop) ‚Ä¢ You want to safely undo a specific commit while keeping the history. ‚Ä¢ You need traceability and accountability for changes. Example: bash CopyEdit git revert # Creates a new commit that undoes the target

---

üí° Tip: Use reset during local development. Use revert when collaborating with others.

Week 4: Git & GitHub Advanced Challenge This challenge covers advanced Git concepts essential for real-world DevOps workflows. By the end of this challenge, you will: ‚Ä¢ Understand how to work with Pull Requests effectively. ‚Ä¢ Learn to undo changes using Reset & Revert. ‚Ä¢ Use Stashing to manage uncommitted work. ‚Ä¢ Apply Cherry-picking for selective commits. ‚Ä¢ Keep a clean commit history using Rebasing. ‚Ä¢ Learn industry-standard Branching Strategies. Topics Covered

1. Pull Requests ‚Äì Collaborating in teams.
    
2. Reset & Revert ‚Äì Undo changes safely.
    
3. Stashing ‚Äì Saving work temporarily.
    
4. Cherry-picking ‚Äì Selecting specific commits.
    
5. Rebasing ‚Äì Maintaining a clean history.
    
6. Branching Strategies ‚Äì Industry best practices. Challenge Tasks Task 1: Working with Pull Requests (PRs) Scenario: You are working on a new feature and need to merge your changes into the main branch using a Pull Request.
    
7. Fork a repository and clone it locally.
    
8. git clone cd
    
9. Create a feature branch and make changes.
    
10. git checkout -b feature-branch
    
11. echo "New Feature" &gt;&gt; feature.txt
    
12. git add . git commit -m "Added a new feature"
    
13. Push the changes and create a Pull Request. git push origin feature-branch
    
14. Open a PR on GitHub, request a review, and merge it once approved.
    

Steps :- ‚Ä¢ Open your GitHub profile. ‚Ä¢ Navigate to the repository and lick ‚ÄúCompare & Pull Request‚Äù

‚Ä¢ Select the base branch where you want to merge and select from which branch you want to merge. ‚Ä¢ Then create pull request.

‚Ä¢ Once click on the Create pull request.

‚Ä¢ You need to add the Description also you can ask your senior or colleague to review the pull request and the file that you have created. ‚Ä¢ Once you have assigned the reviewers and the description, then you can create pull request.

‚Ä¢ As you can see in the screenshot there is no reviewers in it but assume you have assigned the reviewer and they have reviewed the request and approved it. ‚Ä¢ Once it is approved you can see the latest comment. ‚Ä¢ If it is mentioned that it is approved then you just need to click on merge pull request. ‚Ä¢ Then it will ask you to confirm the merge before that always put description.

‚Ä¢ Once you click on confirm merge then pull request will be succeed.

Document in [solution.md](http://solution.md) ‚Ä¢ Steps to create a PR. ‚Ä¢ Best practices for writing PR descriptions. ‚Ä¢ Handling review comments. üõ†Ô∏è Pull Request (PR) Workflow Guide ‚úÖ Steps to Create a Pull Request (PR)

1. Create a Feature Branch
    

git checkout -b feature/your-feature-name 2. Make Changes and Commit git add . git commit -m "Add a meaningful commit message" 3. Push the Feature Branch git push origin feature/your-feature-name 4. Open a Pull Request on GitHub o Navigate to the repository. o Click "Compare & Pull Request". o Choose the base branch (e.g., main or develop) and your feature branch. o Add a title and description, then click "Create Pull Request".

---

‚úçÔ∏è Best Practices for Writing PR Descriptions Clear communication in PRs improves collaboration and code quality. Structure your description like this: üîç What does this PR do? Brief summary of the change. E.g., "Implements login functionality using JWT." üìã Changes made ‚Ä¢ Added authService.ts for token generation. ‚Ä¢ Updated login API to validate credentials. ‚Ä¢ Added unit tests. ‚úÖ Checklist ‚Ä¢ Code is linted ‚Ä¢ Unit tests added ‚Ä¢ No breaking changes üìù Related Issue Closes #123 or Fixes bug described in \[link\]

---

üí¨ Handling Review Comments

1. Stay open to feedback Reviews are about the code, not you.
    
2. Reply to each comment Acknowledge the feedback. Use: o ‚úÖ Fixed o ü§î Need clarification o üö´ Won‚Äôt fix (with reason)
    
3. Make necessary changes Update your branch with changes and push again: git add . git commit -m "Refactor: address review feedback" git push origin feature/your-feature-name
    
4. Resolve comments on GitHub Mark them as "Resolved" once handled.
    

Task 2: Undoing Changes ‚Äì Reset & Revert Scenario: You accidentally committed incorrect changes and need to undo them.

1. Create and modify a file.
    
2. echo "Wrong code" &gt;&gt; wrong.txt
    
3. git add .
    

git commit -m "Committed by mistake"

4. Soft Reset (keeps changes staged). git reset --soft HEAD~1:- it will untrack and stag the file last committed file.
    
5. Mixed Reset (unstages changes but keeps files). git reset --mixed HEAD~1 :- it will untrack the file last committed file.
    
6. Hard Reset (removes all changes). git reset --hard HEAD~1 :- it will delete the file last committed file.
    

As you can see wrong file is deleted and it also not in untrack.

7. Revert a commit safely. git revert HEAD :- it will revert the last head commit. As per last command git reset ‚Äìhard it will delete the committed the file(wrong file) and the log for it. Not when you do revert HEAD then it will revert the last committed file that will feature file which was committed in task 1.
    

Document in [solution.md](http://solution.md) ‚Ä¢ Differences between reset and revert. ‚Ä¢ When to use each method.

üîÅ Differences Between git reset and git revert üß† Conceptual Difference Feature git reset git revert What it does Moves the branch pointer to an earlier commit Creates a new commit that undoes a previous one Affects history Rewrites commit history Preserves history Safe for shared branches ‚ùå No (can cause issues for others) ‚úÖ Yes (safe for collaboration) Undo visibility Changes are not visible to others (unless pushed with --force) Revert is visible as a new commit

---

üß™ When to Use Each Method ‚úÖ Use git reset when: ‚Ä¢ You're working locally, and ‚Ä¢ You want to undo commits or unstage files without keeping the history. ‚Ä¢ Useful during development or practice. Example: bash CopyEdit git reset --soft HEAD~1 # Undo commit but keep changes staged git reset --mixed HEAD~1 # Undo commit and unstage changes git reset --hard HEAD~1 # Undo commit and discard changes (use with caution!) ‚úÖ Use git revert when: ‚Ä¢ You're working on a shared branch (e.g., main, develop) ‚Ä¢ You want to safely undo a specific commit while keeping the history. ‚Ä¢ You need traceability and accountability for changes. Example: bash CopyEdit git revert # Creates a new commit that undoes the target

---

üí° Tip: Use reset during local development. Use revert when collaborating with others.

üîß Task 3: Stashing - Save Work Without Committing Scenario: I was working on a file (temp.txt) but had to switch branches. The catch? I didn‚Äôt want to commit half-done work. That‚Äôs where git stash saved the day. ‚úÖ Steps Performed: bash CopyEdit echo "Temporary Change" &gt;&gt; temp.txt git add temp.txt git stash git checkout main git stash pop üß† What I Learned: ‚Ä¢ When to use git stash: Use it when you want to temporarily save changes that aren't ready to be committed ‚Äî especially useful when you need to switch branches quickly. ‚Ä¢ git stash pop vs git stash apply: o git stash pop: Applies the most recent stash and deletes it from the stash list. o git stash apply: Applies the stash but keeps it in the list in case you need it again. üì∏ Screenshot of stash in action:

---

üçí Task 4: Cherry-Picking - Selectively Apply Commits Scenario: I had a bug fix committed in another branch. Instead of merging the whole branch, I used cherry-pick to bring over just that fix. ‚úÖ Steps Performed: bash CopyEdit git log --oneline git cherry-pick

# In case of conflicts:

git cherry-pick --continue üß† What I Learned: ‚Ä¢ Use case in bug fixes: Cherry-picking is perfect for quickly applying bug fixes or patches from one branch to another without merging unrelated work. ‚Ä¢ Risks of cherry-picking: o Can create duplicate commits if misused. o Might cause confusion in commit history if not documented properly. üì∏ Screenshot of cherry-pick execution:

![image](https://github.com/user-attachments/assets/8e7b0783-e355-4f5e-bf64-aaba8e4be53a align="left")

---

üîÑ Task 5: Rebasing - Keeping a Clean Commit History Scenario: My feature-branch was behind main. Instead of using a merge (which creates extra commits), I opted for rebase to keep the history clean. ‚úÖ Steps Performed: bash CopyEdit git fetch origin main git rebase origin/main

# Resolve any conflicts:

git rebase --continue üß† What I Learned: ‚Ä¢ Merge vs Rebase: o Merge: Brings all commits together but creates a merge commit. o Rebase: Rewrites your local commits on top of the latest main ‚Äî much cleaner history. ‚Ä¢ Best Practices: o Always rebase local branches before opening a PR. o Avoid rebasing shared/public branches to prevent history rewrite issues. üì∏ Screenshot of rebase process:

![image](https://github.com/user-attachments/assets/367182ae-463b-401b-845c-d4b7327f098c align="left")

---

üöÄ Final Thoughts These advanced Git tools ‚Äî stashing, cherry-picking, and rebasing ‚Äî are game changers for maintaining productivity and code hygiene in collaborative environments. Practicing them during this challenge has given me deeper confidence in handling real-world Git workflows.